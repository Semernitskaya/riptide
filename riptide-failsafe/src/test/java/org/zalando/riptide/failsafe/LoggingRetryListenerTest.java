package org.zalando.riptide.failsafe;

import com.google.gag.annotation.remark.Hack;
import dev.failsafe.Failsafe;
import dev.failsafe.RetryPolicy;
import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.springframework.http.client.ClientHttpResponse;
import org.zalando.riptide.RequestArguments;
import org.zalando.riptide.failsafe.RetryRequestPolicy.RetryListenerAdapter;

import java.util.Objects;
import java.util.concurrent.atomic.AtomicBoolean;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;

final class LoggingRetryListenerTest {

    private final Logger logger = mock(Logger.class);
    private final RetryListener unit = new LoggingRetryListener(logger);

    @Test
    void shouldLogFailure() {
        final AtomicBoolean success = new AtomicBoolean(false);

        final RequestArguments arguments = RequestArguments.create();
        final IllegalStateException exception = new IllegalStateException();

        Failsafe.with(RetryPolicy.<ClientHttpResponse>builder()
                .withMaxRetries(3)
                .onRetry(new RetryListenerAdapter(unit, arguments))
                        .build())
                .run(() -> {
                    if (!success.getAndSet(true)) {
                        throw exception;
                    }
                });

        verify(logger).warn(any(), eq(exception));
    }

    @Test
    void shouldNotLogResults() {
        final AtomicBoolean success = new AtomicBoolean(false);

        final RequestArguments arguments = RequestArguments.create();

        Failsafe.with(RetryPolicy.<ClientHttpResponse>builder()
                .withMaxRetries(3)
                .handleResultIf(Objects::isNull)
                .onRetry(new RetryListenerAdapter(unit, arguments))
                        .build())
                .get(() -> {
                    if (!success.getAndSet(true)) {
                        return null;
                    }

                    return mock(ClientHttpResponse.class);
                });

        verifyNoMoreInteractions(logger);
    }

    @Hack("We're not really testing anything here, since we don't want to clutter the logs.")
    @Test
    void shouldUseDefaultLogger() {
        new LoggingRetryListener();
    }

}
